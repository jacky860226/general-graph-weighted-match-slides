<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>一般圖最大權匹配</title>
		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
		<link rel="stylesheet" href="reveal/css/reveal.css">
		<link rel="stylesheet" href="reveal/css/theme/black.css" id="theme">
		<link rel="stylesheet" href="css/style.css"><!-- Code syntax highlighting -->
		<link rel="stylesheet" href="reveal/lib/css/zenburn.css">
		<!-- Printing and PDF exports --><script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal/css/print/pdf.css' : 'reveal/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script><!--[if lt IE 9]><script src="lib/js/html5shiv.js"></script><![endif]-->
	</head>
	<body>
	<div></div>
	<div class="reveal">
		<div class="slides">\( 
			  \newcommand{\ord}[1]{\mathcal{O}\left(#1\right)}
			  \newcommand{\abs}[1]{\lvert #1 \rvert}
			  \newcommand{\floor}[1]{\lfloor #1 \rfloor}
			  \newcommand{\ceil}[1]{\lceil #1 \rceil}
			  \newcommand{\opord}{\operatorname{\mathcal{O}}}
			  \newcommand{\argmax}{\operatorname{arg\,max}}
			  \newcommand{\str}[1]{\texttt{"#1"}}
			\)
			<!-- ... 這裡是註解文字 ... -->
			<section>
				<h1>一般圖最大權匹配</h1>
				<p><div class="small">general graph weighted match</div></p>
				<p><div class="small">南天門日月卦長</div></p>
			</section>
			<section>
				<section>
					<h1>甚麼是匹配?</h1>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 匹配
						
						一張圖G=(V,E)，這張圖的一個匹配M是圖G的一個子圖，其中每兩條邊都不相鄰（沒有公共頂點）
						
						![Alt text](img/Maximal-matching.svg)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 最大匹配
						圖G的一個**最大匹配**是另一個概念，指邊數最多的匹配。
						
						**最大匹配**可能有不止一個，但**最大匹配**的邊數是確定的，並且不可能超過圖中頂點數的一半。
						
						![Alt text](img/Maximum-matching-labels.svg)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 完美匹配
						若圖G的**最大匹配**包含所有原圖的所有點，稱為**完美匹配**
						
						若G為完全圖且頂點數為偶數時，必然存在**完美匹配**
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 最大權匹配
						##### maximum weight matching
						一張圖G=(V,E)，∀ e ∈ E 存在一個函數 w(e) 表示e的權重
						
						這張圖的一個**最大權匹配**M=(V',E')是圖G的一個子圖
						
						滿足 ∀ e ∈ E', ∑ w(e) 為其所有匹配中最大的
						
						![Alt text](img/example_weighted_graph.png)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 最大權最大匹配
						##### maximum weight maximum cardinality matching
						圖G的一個**最大權最大匹配**M=(V',E')
						
						滿足 ∀ e ∈ E', ∑ w(e) 為其所有 **"最大匹配"** 中最大的
						
						![Alt text](img/example_max_edge_weighted_graph.png)
					</script>
				</section>
			</section>
			<section>
				<h1>匹配算法的轉換</h1>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						## 用
						## 最大權最大匹配
						## 求
						## 最大權匹配
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						**最大權最大匹配**允許負權邊( w(e) < 0 )
						
						但是**最大權匹配**不會有負權邊
						
						一張圖G若其所有的邊皆為負權，則其**最大權匹配**M為∅
						
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 調整邊的權重
						
						先將圖G的所有負權邊其權重 w(e) 設為0
						
						在進行接下來的步驟
					</script>
				</section>
				
				<section data-markdown>
					<script type="text/template">
						## 完全圖性質
						在G為完全圖且沒有負權邊時
						
						**最大權最大匹配** = **最大權匹配**
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						所以把G補成完全圖，補上的邊其權重為0
						
						計算**最大權最大匹配**後再把權重為0的邊去除即可
						
						![Alt text](img/example_max_edge_weighted_graph-change.png)
					</script>
				</section>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						## 用
						## 最大權匹配
						## 求
						## 最大權最大匹配
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						**最大權匹配**不會有負權邊
						
						且零邊( w(e) = 0 )可選可不選
						
						但是**最大權最大匹配**允許負權邊和零邊
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 調整邊的權重
						令 K = max( |w(e)| ) + 1 , ∀ e ∈ E 且 w(e) <= 0
						
						若沒有負權邊或零邊則 K = 0
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 調整邊的權重
						把圖G中所有的邊其權重w(e)加上K產生一張新圖G'=(V,E')
						
						此時的新圖G'不存在負權邊和零邊
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 問題來了
						**最大權最大匹配** 不一定等於 **最大權匹配**
						
						但是把所有邊的邊權加上一個超大數字P的話
						
						**最大權匹配**的結果就是**最大權最大匹配**
						
						但是P取要多大?
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 調整邊的權重
						令 P = max( w(e) ) , ∀ e ∈ E'
						
						把圖G'中所有的邊其權重w(e)加上P產生一張新圖G''=(V,E'')
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						此時對圖G''進行**最大權匹配**
						
						其結果可以對應原圖的**最大權最大匹配**
						
						![Alt text](img/example_max_weighted_graph-change.png)
					</script>
				</section>
			</section>
			<section>
				<h1>最大匹配算法</h1>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						# 二分圖最大匹配
						## Bipartite Matching
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## flow
						最簡單的方法是用網路流，所以就不多講了
						
						Dinic在這種特殊圖上複雜度為O( |E|*sqrt(|V|) )
						
						![Alt text](img/flow-matching.png)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 匈牙利算法
						這是這份投影片主要要講的
						
						在學習他之前必須要有一些預備知識
					</script>
				</section>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						# 匈牙利算法-預備知識
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 定義
						
						**匹配點**
						
						**匹配邊**
						
						**未匹配點**
						
						**非匹配邊**
						
						它們的含義非常顯然
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						交替路(Alternating Path)：從一個未匹配點出發，依次經過非匹配邊、匹配邊、非匹配邊…形成的路徑叫交替路。

						增廣路(Agumenting Path)：從一個未匹配點出發，走交替路，如果途徑另一個未匹配點(出發的點不算)，則這條交替路稱為增廣路。
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						![Alt text](img/Bipartite.png)
						![Alt text](img/BipartiteAgumentingPath.png)
						
						原圖和增廣路
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						有沒有人發現把增廣路的匹配邊和非匹配邊反轉就可以增加匹配數量?
						
						匈牙利算法中只透過這樣的方式增加匹配數量
						
						稱為Augment(擴充)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						那如果有一個未匹配點，找不到以此點作為端點的增廣路(無法擴充)怎麼辦?
					</script>
				</section>
				<section>
					<h2>Berge's Theorem</h2>
					<div class="theorem">
						<div class="label">定理</div>
						Berge's Theorem<hr>
						從圖上任取一個未匹配點，如果找不到以此點作為端點的增廣路，那麼這張圖會有一些最大匹配不會包含此點。
					</div>
					<div class="fragment">接下來我們要來證明Berge's Theorem</div>
				</section>
				<section>
					<h2>對稱差集</h2>
					<div class="theorem">
						<div class="label">定義</div>
						對稱差集<hr>
						兩個集合 A 和 B 的「對稱差集」定義為 A⊕B = (A∪B) - (A∩B)
					</div>
				</section>
				<section>
					同一張圖上的兩種匹配 M 和 M* 也可以計算對稱差集<br>
					M⊕M*總共會產生六大類 connected component
				</section>
				<section data-markdown>
					<script type="text/template">
						![Alt text](img/connected_component.png)
					</script>
				</section>
				<section>
					令當下的匹配M找不到以未匹配點p作為端點的擴充路徑<br>
					並令M*是該圖的其中一個最大匹配。
				</section>
				<section>
					<h2>如果p不在M*上</h2>
					<div class="theorem">
						<div class="label">證明</div>
						Berge's Theorem<hr>
						刪除此點完全不會對M和M*有任何影響，定理成立。
					</div>
				</section>
				<section>
					<h2>如果p在M*上</h2>
					<div class="theorem">
						<div class="label">證明</div>
						Berge's Theorem<hr>
						1. p對於M來說是未匹配點。理所當然p不在M上。<br>
						2. 考慮M⊕M*的六種情形。p不在M上，且p在M*上，所以只有d或e符合條件。<br>
						3. M找不到以p作為端點的擴充路徑，所以d不符合條件，只有e符合條件。<br>
						4. 對於M*來說，只要照著e顛倒匹配邊和未匹配邊，
						就可以製造出另一個不會包含p的最大匹配，
						成為1.的情形，定理還是成立。
					</div>
					<div class="fragment">結論:Berge's Theorem是正確的</div>					
				</section>
			</section>
			<section>
				<section>
					<h1>匈牙利算法</h1>
				</section>
				<section data-markdown>
					<script type="text/template">
						有了Berge's Theorem<br>
						我們可以用以下的方法找最大匹配
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						一開始圖上所有點都是未匹配點<br>
						將圖上每一個未匹配點都嘗試作為增廣路的端點
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 如果找得到增廣路:
						沿著增廣路修改現有匹配(擴充)<br>
						此未匹配點變成了匹配點
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 如果找不到擴充路徑
						直接刪除此點<br>
						繼續下去仍然可以找到原圖的其中一個最大匹配
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 接下來來看code
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						用vector存圖<br>
						若G[x]=y，則x和y之間有一條邊<br>
						match為匹配結果，若match[y]=x<br>
						則x和y之間有一條匹配邊
						
						注意:因為是二分圖，可以把點分成兩個集合<br>
						x和y在不同的集合，所以編號可以一樣
						``` cpp
						#define MAXN 1000
						vector<int> G[MAXN];
						int match[MAXN];
						int n;//n個點，編號為0 ~ n-1
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						bool vis[MAXN];
						bool dfs(int x){
							for(size_t i=0;i<G[x].size();++i){
								int y=g[x][i];
								if(vis[y])continue;
								vis[y]=true;
								if(match[y]==-1||dfs(match[y])){
									match[y]=x;
									return true;
								}
							}
							return false;
						}
						```
						如果有增廣路就進行擴充並return true<br>
						否則return false
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 最後是主函數
						``` cpp
						inline int max_match(){
							int ans=0;
							memset(match,-1,sizeof(int)*n);
							for(int x=0;x<n;++x){
								memset(vis,0,sizeof(bool)*n);
								if(dfs(x))++ans;
							}
							return ans;
						}
						```
						ans為最大匹配數量
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 複雜度
						總共做了|V|次dfs，每次dfs花了O( max(|V|,|E|) )的時間<br>
						總複雜度為O( |V|*max(|V|,|E|) )
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 複雜度
						好像比網路流慢?
						
						這個方法好寫，而且可以求字典序最小的最大匹配
					</script>
				</section>
			</section>
			<section data-markdown>
				<script type="text/template">
					# 一般圖最大匹配
					## General Graph Matching
				</script>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						# 帶花樹算法
						## Blossom algorithm
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						一般圖跟二分圖最大的差別就是奇環<br>
						在交替路上行走的時候，如果遇到奇環<br>
						那就把奇環縮成一朵花(blossom)<br>
						並把花中所有點設成偶點
						
						既然花上的點都可以成為偶點<br>
						那麼乾脆把花直接縮成一個偶點<br>
						會讓交錯樹變得更簡潔明白
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						![Alt text](img/750px-Edmonds_blossom.svg.png)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						縮花之後把整個花當成一個點<br>
						值得注意的是，花裡可以包含其它花
						
						繼續尋找增廣路，如果有找到增廣路<br>
						和匈牙利算法一樣，必須擴充路徑<br>
						這個時候要處理花的問題<br>
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						![Alt text](img/750px-Edmonds_lifting_path.svg.png)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						這樣基本問題就解決了，來計算一下時間複雜度
						
						因為一朵花最少有三個點，縮花後成為一個點<br>
						由此推得：N個點的圖建立一棵交錯樹，最多縮花N/2次
						
						所以找出增廣路的時間複雜度為<br>
						O( max(|E|,|V|) ) + O( max(|E|,|V|) ) = O( max(|E|,|V|) )<br>
						BFS的時間加上縮花的時間
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 接著就用匈牙利算法來求最大匹配
					</script>
				</section>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						# 實作細節
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## BFS
						首先是BFS，如果不用BFS的話
						
						奇點變偶點的操作會很難處理
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 如何記錄花
						1. disjoint set
						  * 想法簡單
						  * code略長
						2. 只記錄有可能增廣的邊
						  * 效率高
						  * 好實作
						
						##這裡使用方法2
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 可能增廣的邊
						一朵花裡可能會有其他的花<br>
						那花裡也可能會包含其他花<br>
						層層疊疊
						
						但是增廣的時候只會有一條路徑被增廣
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 可能增廣的邊
						因為花是在BFS時建構出來的<br>
						BFS之後要把花拆掉<br>
						
						所以一朵花只會有一個奇環<br>
						其環上的某條鏈有機會被增廣<br>
						
						因此只需要紀錄哪些點在這個環上即可
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						圖中節點的編號為BFS順序<br>
						白色的部分表示還沒遍歷<br>
						灰色表示一般節點<br>
						相同顏色表示在相同的花裡面<br>
						
						可以看出 3 和 9 在黃色的花和藍色的花形成時被遺棄了
						
						![Alt text](img/blossom.gif)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 可能增廣的邊
						不需要擔心被遺棄的節點<br>
						之後不會再經過且不可能被增廣
					</script>
				</section>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						# 來看看code
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						#define MAXN 505
						vector<int>g[MAXN];//用vector存圖 
						int pa[MAXN],match[MAXN],st[MAXN],S[MAXN],vis[MAXN];
						//pa表示交錯樹每個節點的父母節點
						//match[u]=v表示u和v匹配，同時match[v]=u
						//st[u]=B表示節點u屬於B這朵花
						//S[u]={-1:沒走過 0:偶點 1:奇點}
						//vis只用在找lca的時候檢查是不是走過了
						int n;//n個點，編號為1 ~ n
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						inline int lca(int u,int v){
							//找花的花托，也就是交錯樹的lca
							//這種方法可以不用清空vis陣列就可以判斷有沒有經過
							static int t=0;
							for(++t;;swap(u,v)){
								if(u==0)continue;
								if(vis[u]==t)return u;
								vis[u]=t;
								u=st[pa[match[u]]];
							}
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						#define qpush(u) q.push(u),S[u]=0
						//因為丟進queue裡的節點必為偶點，故把兩個操作寫在一起
						
						inline void flower(int u,int v,int l,queue<int> &q){
							//這個函數用來設定花裡面所有點的pa
							while(st[u]!=l){
								pa[u]=v;//所有未匹配邊的pa都是雙向的 
								v=match[u];
								if(S[v]==1)qpush(v);//所有奇點變偶點 
								st[u]=st[v]=l;
								//注意這邊以花的花托代表這個花<br>
								//所以 st[u]=st[v]=l 就是設定 u 和 v 屬於 l 這朵花
								u=pa[v];
							}
						}
						```
						執行
						``` cpp
						flower(v,u,lca,q);
						flower(u,v,lca,q);
						```
						就可以設定花裡面所有點的pa
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						執行
						``` cpp
						flower(v,u,lca,q);
						flower(u,v,lca,q);
						```
						的結果
						
						![Alt text](img/pa_set.png)
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						inline bool agument(int u,int v){
							//擴充增廣路
							for(int lst;u;v=lst,u=pa[v]){
								lst=match[u];
								match[u]=v;
								match[v]=u;
							}
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						inline bool bfs(int u){
							for(int i=1;i<=n;++i)st[i]=i;//自己一個點也是奇環
							memset(S+1,-1,sizeof(int)*n);
							queue<int>q;
							qpush(u);
							while(q.size()){
								u=q.front(),q.pop();
								for(size_t i=0;i<g[u].size();++i){
									int v=g[u][i];
									if(S[v]==-1){
										pa[v]=u;
										S[v]=1;
										if(!match[v]){//有增廣路直接擴充 
											agument(u,v);
											return true;
										}
										qpush(match[v]);
									}else if(!S[v]&&st[v]!=st[u]){
										int l=lca(v,u);//遇到花，做花的處理 
										flower(v,u,l,q);
										flower(u,v,l,q);
									}
								}
							}
							return false;
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 最後是主函數
						``` cpp
						inline int blossom(){
							//ans表示最大匹配數量
							memset(pa+1,0,sizeof(int)*n);
							memset(match+1,0,sizeof(int)*n);
							int ans=0;
							for(int i=1;i<=n;++i)
								if(!match[i]&&bfs(i))++ans;
							return ans;
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 複雜度分析
						之前有討論過bfs加上縮花的時間為O( max(|E|,|V|) )<br>
						總共會進行|V|次bfs
						
						故總複雜度為O( |V|*max(|E|,|V| ) )
					</script>
				</section>
			</section>
			<section data-markdown>
				<script type="text/template">
					# 接下來討論帶權匹配的問題
				</script>
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						# 預備知識
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 線性規劃的對偶(duality)
						一個線性規劃問題可以從兩個不同的角度來分析<br>
						其一，評估每一產品的獲利情況，而使總利潤極大化<br>
						另一為評估生產產品所付出的成本，而使總成本極小化<br>
						實為一物的兩面，從不同的角度觀察同一問題
					</script>
				</section>
				<section>
					<h2>定義函數</h2>
					設\(S ⊆ V\)<br>
					\(δ(S) = \{ (u, v) ∈ E \; | \; u ∈ S, \; v ∈ V − S \} \)<br>
					對單一點 \(v ∈ V \) ，我們定義 \(δ(v) = δ(\{v\}) \)<br>
				</section>
				<section>
					<h2>二分圖最大權匹配的線性規劃</h2>
					<div class="prob">
						<div class="label">原始問題</div>
						PRIMAL<hr>
						<p>\( max \; \sum_{e∈E} \; w(e)x_e \)</p>
						<p>
							限制:<br>
							\(x_e ≥ 0, \; \forall e∈E \)<br>
							\( x(δ(u)) = 1, \; \forall u∈V \)
						</p>
						定義:<br>
						\(x(S) = \sum_{e∈S} \; x_e\)
					</div>
					<div class="fragment">接下來進行對偶問題的轉換</div>					
				</section>
				<section>
					<h2>二分圖最大權匹配的對偶問題</h2>
					<div class="prob">
						<div class="label">對偶問題</div>
						DUAL<hr>
						<p>\( min \; \sum_{u \in V} \; z_u \)</p>
						<p>
							限制:<br>
							\(z_e ≥ 0, \; \forall e∈E \)
						</p>
						設 \(e=(u,v)\)，這裡\(z_e = z_u + z_v - w(e)\)
					</div>
					<div class="fragment">所有條件都滿足時\(\sum_{u∈V} \; z_u\)就是最大權匹配的權重和</div>
					<div class="fragment">原本求最大值問題就變成求最小值了!</div>
				</section>
				<section>
					<h2>二分圖最大權匹配的對偶問題</h2>
					<p>
						我們稱\(z_u\)為u的vertex labeling<br/>
						稱\(z_e=0\)的邊為等邊(Equality Edge)
					</p>
					在最大權匹配的時候<br/>
					所有匹配邊都會是等邊
				</section>
				<section>
					<p>
						以「等邊」的概念，結合之前的匈牙利算法:
					</p>
					<p>
						用「等邊」構成的增廣路不斷進行擴充<br/>
						由於用來擴充的邊全是「等邊」<br/>
						最後一定得到的最大權匹配當然全是「等邊」
					</p>
					<div class="fragment">找不到「等邊」?只好調整vertex labeling了</div>
				</section>
				<section>
					<h2>調整 vertex labeling</h2>
					<div class="theorem">
						<div class="label">調整</div>
						vertex labeling<hr>
						<p>
							vertex labeling 仍要維持大於等於的性質<br>
							而且既有的「等邊」不能被改變。
						</p>
						設 \(T=(V_t,E_t)\)為在尋找增廣路時產生的交錯樹<br>
						定義:<br>
						偶點為樹上深度為偶數的點<br>
						奇點為樹上深度為奇數的點
					</div>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 原圖及交錯樹
						![Alt text](img/originalB.png)
						![Alt text](img/search tree.png)
					</script>
				</section>
				<section>
					<h2>調整 vertex labeling</h2>
					<div class="theorem">
						<div class="label">調整</div>
						vertex labeling<hr>
						<p>
							令 \( d = min(z_e), \; \forall e \in E_t\)<br/>
							讓 \(z_u\)-= \(d, \;\)\(z_v\) += \(d\)<br/>
							\(u\)為樹上偶點，\(v\)為樹上奇點
						</p>

						如此便製造了一條(以上)的等邊，且既有等邊保持不動<br/>
						並維持了\(z_e ≥ 0, \; \forall e∈E \)的性質<br/>
						接著就繼續找增廣路!
					</div>
				</section>
				<section>
					二分圖本身就可以把點分成兩個集合<br/>
					所以可以把其中一個集合作為奇點，另一個集合作為偶點
					<div class="theorem">
						我們一開始的時候可以設定:<br/>
						所有\(u\)為偶點，\(z_u=max(\{w(e)|\forall e \in E\})\)<br/>
						所有\(v\)為奇點，\(z_v=0\)
					</div>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 還是會有問題
						這樣做找出來的匹配是最大權最大匹配<br/>
						我們想要的是最大權匹配
						
						沒關係，把圖補成完全二分圖就行了<br/>
						雖然有辦法直接做最大權匹配(等下會說)<br/>
						但是這樣code會比較好寫
					</script>
				</section>
				<section>
					<h2>如果要做最大權二分匹配</h2>
					<div class="theorem">
						<p>
							vertex labeling 額外增加一個限制：<br>
							\(z_u > 0, \; \forall u∈V \)
						</p>
						vertex labeling為 0 的點最後將成為未匹配點
					</div>
					<div class="fragment">實作也不會太難大家可以試試看</div>
				</section>
			</section>
			<section>
				<section>
					<h1>KM演算法</h1>
					Kuhn-Munkres algorithm
				</section>
				<section>
					<h3>這個算法可以求二分圖的最大權完美匹配</h3>
				</section>
				<section>
					<h1>code</h1>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						int n;
						int g[MAXN][MAXN],lx[MAXN],ly[MAXN],slack_y[MAXN];
						//用鄰接矩陣存二分圖，把點分成X、Y兩個集合
						//lx[x],ly[y]為x,y的vertex labeling
						//slack_y[y]紀錄和y相鄰的最小「非等邊」值
						int match_y[MAXN];
						//match_y[y]=x表示y和x匹配
						bool vx[MAXN],vy[MAXN];
						//vx,vy是dfs的時候判斷有沒有走過用的
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						``` cpp
						bool dfs(int x){
							if(vx[x])return 0;
							vx[x]=1;
							for(int y=0,d;y<n;++y){
								if(vy[y])continue;
								d=lx[x]+ly[y]-g[x][y];
								if(d==0){//等邊
									vy[y]=1;
									if(match_y[y]==-1||dfs(match_y[y])){
										match_y[y]=x;
										return 1;
									}
								}else if(slack_y[y]>d)slack_y[y]=d;
								//非等邊，計算slack值
							}
							return 0;
						}
						```
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## 接下來是主程式
						``` cpp
						inline int km(){
							memset(ly,0,sizeof(int)*n);
							memset(match_y,-1,sizeof(int)*n);
							for(int x=0;x<n;++x){
								lx[x]=-INF;
								for(int y=0;y<n;++y){
									lx[x]=max(lx[x],g[x][y]);
								}
							}
							for(int x=0;x<n;++x){
								for(int y=0;y<n;++y)slack_y[y]=INF;
								for(;;){
									memset(vx,0,sizeof(bool)*n);
									memset(vy,0,sizeof(bool)*n);
									if(dfs(x))break;//找到增廣路所以離開
									int d=INF;
									for(int y=0;y<n;++y){
										if(!vy[y])d=min(d,slack_y[y]);
									}
									//修改vertex labeling產生新的等邊
									for(int j=0;j<n;++j){
										if(vx[j])lx[j]-=d;
										if(vy[j])ly[j]+=d;
										else slack_y[j]-=d;
									}
								}
							}
							int ans=0;
							for(int y=0;y<n;++y)
								if(g[match_y[y]][y]!=-INF)
									ans+=g[match_y[y]][y];
							return ans;
						}
						```
					</script>
				</section>
				<section>
					<h2>複雜度分析</h2>
					<div class="theorem">
						<div class="label">複雜度</div>
						KM演算法<hr>
						<p>dfs花\(O(|V|^2)\)的時間</p>
						<p>
							因為交錯樹最多有\(|V|-1\)條邊<br/>
							故主程式裡的無限迴圈最多執行\(O(|V|)\)次<br/>
						</p>
						<p>總共有\(|V|\)個點需要被增廣</p>
						總複雜度為:<br/>
						\(O(|V|*|V|*|V|^2)=O(|V|^4)\)
					</div>
				</section>
				<section>
					<h2>還可以更好</h2>
					<div class="theorem">
						<div class="label">複雜度</div>
						KM演算法<hr>
						其實這算法複雜度可以到\(O(|V|^3)\)<br/>
						\(\implies\)每次增加新的等邊後不需要重新DFS<br>
						<div class="fragment">怎麼實作具體就留給你們吧</div>
					</div>
				</section>
			</section>
		</div>
		<!--結束了-->
	</div>
	<script src="js/jquery.js"></script>
	<script src="reveal/lib/js/head.min.js"></script>
	<script src="reveal/js/reveal.js"></script>
	<script src="js/sketch.min.js"></script>
	<script>// Full list of configuration options available at:
	// https://github.com/hakimel/reveal.js#configuration
	Reveal.initialize({
	  controls: true,
	  progress: true,
	  history: true,
	  center: true,
	  //-showNotes: true,

	  transition: 'slide', // none/fade/slide/convex/concave/zoom

	  // Optional reveal.js plugins
	  dependencies: [
		{ src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
		{ src: 'reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
		{ src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
		{ src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
		{ src: 'reveal/plugin/zoom-js/zoom.js', async: true },
		{ src: 'reveal/plugin/notes/notes.js', async: true },
		{ src: 'reveal/plugin/math/math.js', async: true, callback: function() {
		  setTimeout( function() {
			MathJax.Hub.Config({
			  SVG: {
				scale: 90
				},
			  "HTML-CSS": {
				scale: 90,
				}
			  });
			}, 2000);
		  },
		  config: 'TeX-AMS_HTML-full'
		},
		{ src: 'js/dazzleSketch.js', async: true }
	  ]
	});</script>
	</body>
</html>